**This is API with a single GET request that returns True/False information.**

1. Install the required dependencies:

**pip install fastapi pydantic sqlalchemy alembic**

2. Run the FastAPI app using Uvicorn:

**uvicorn main:app --workers 10 --reload**

This will start the FastAPI app with 10 Docker workers and automatic reloading enabled.

3. Now, you can make a GET request to **http://localhost:8000/check_request_status** to check the availabillity of the third-party API.
The response will contain the **can_make_request** field, which will be **True** or **False** depending on the current status.

4. Install pytest:

**pip install pytest**

5. Run the tests using pytest:

**pytest**



---



**1. Создаем файл main.py**


**2. Настраиваем подключение к базе данных с помощью SQLAlchemy на Python.**


Построчно:


1.) `SQLALCHEMY_DATABASE_URL = "sqlite:///./api.db"`: В этой строке задается URL для базы данных SQLite. В этом случае он использует relative path к файлу с именем `api.db` в текущей директории.


2.) `engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}, poolclass=SingletonThreadPool)`: Эта строка создает объект engine, используя функцию `create_engine` из SQLAlchemy. Движок отвечает за подключение к базе данных и выполнение SQL. Параметр `connect_args` используется для передачи дополнительных аргументов подключению к базе данных, в этом случае `check_same_thread=False` используется для SQLite, чтобы разрешить нескольким потокам доступ к базе данных. Параметр `poolclass=SingletonThreadPool` настраивает движок на использование пула одноэлементных потоков, который подходит для SQLite.


3.) `SessionLocal = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))`: Эта строка создает объект сеанса с ограниченной областью действия, используя функцию `scoped_session` из SQLAlchemy. Сеанс представляет собой область транзакций для взаимодействия с базой данных. Функция `sessionmaker` используется для создания фабрики сеансов, а параметру `bind` присваивается значение объекта `engine`, созданного на предыдущем шаге. Параметры `autocommit=False` и `autoflush=False` настраивают сеанс таким образом, чтобы он автоматически не фиксировал изменения и не сбрасывал ожидающие изменения в базу данных.


4.) `Base = sqlalchemy.orm.declarative_base()`: Эта строка создает базовый класс для декларативных моделей, используя функцию `declarative_base` из SQLAlchemy. Декларативные модели позволяют определять таблицы базы данных как классы Python.


5.) `Base.query = SessionLocal.query_property()`: Эта строка добавляет атрибут `query` к классу `Base`, который является свойством, возвращающим объект запроса, связанный с сеансом `SessionLocal`. Это позволяет запрашивать базу данных, используя класс `Base` в качестве отправной точки.


В целом, этот код устанавливает подключение к базе данных SQLite, создает сеанс для взаимодействия с базой данных и определяет базовый класс для декларативных моделей.


**3. Определяем model class SQLAlchemy с именем RequestCounter, который представляет таблицу в базе данных.**


Построчно:


1.) `class RequestCounter(Base):`: Эта строка определяет новый класс с именем `RequestCounter`, который наследуется от класса `Base`. Класс `Base` является базовым классом для декларативных моделей в SQLAlchemy.


2.) `__tablename__ = "request_counter"`: Эта строка задает имя таблицы в базе данных, которая будет связана с моделью `RequestCounter`. В этом случае имя таблицы - "request_counter".


3.) `id = Column(Integer, primary_key=True, index=True)`: Эта строка определяет столбец с именем `id` типа `Integer` в таблице. Параметр `primary_key=True` указывает, что этот столбец является первичным ключом для таблицы, а параметр `index=True` создает индекс для этого столбца для более быстрого запроса.


4.) `count = столбец (целое число, по умолчанию=0)`: Эта строка определяет столбец с именем `count` типа `Integer` в таблице. Параметр `default=0` устанавливает значение по умолчанию для этого столбца равным 0.


5) `updated_at = Column(DateTime, по default=datetime.now)`: Эта строка определяет столбец с именем `updated_at` типа `DateTime` в таблице. Параметр `default=datetime.now` устанавливает значение по умолчанию для этого столбца на текущую дату и время при вставке новой строки.


В целом, этот код определяет класс модели SQLAlchemy `RequestCounter` с тремя столбцами (`id`, `count` и `updated_at`), которые будут сопоставлены с таблицей с именем "request_counter" в базе данных.


**4. Создаем таблицы базы данных на основе определенных моделей SQLAlchemy.**


Построчно:


`Base.metadata.create_all(bind=engine)`: 


В этой строке используется метод `create_all` атрибута `metadata` класса `Base` для создания таблиц базы данных. Параметру `bind` присваивается значение объекта `engine`, который был создан ранее. Этот метод сканирует все определенные модели (классы, которые наследуются от `Base`) и создает соответствующие таблицы в базе данных, если они еще не существуют.


В целом, эта строка кода создает необходимые таблицы в базе данных на основе определенных моделей SQLAlchemy.


**5. Определяем Pydantic класс модели с именем "Response", который представляет структуру ответа API.**


Построчно:


1.) `class Response(BaseModel):`: Эта строка определяет новый класс с именем `Response`, который наследуется от класса `Base Model`, предоставляемого Pydantic. Класс `BaseModel` является базовым классом для моделей Pydantic.


2.) `can_make_request: bool`: Эта строка определяет поле с именем `can_make_request` типа `bool` в модели `Response`. Это поле представляет логическое значение, указывающее, может ли быть выполнен запрос. Pydantic models используют аннотации типов для определения структуры и типов полей.


В целом, этот код определяет класс Pydantic модели `Response` с одним полем `can_make_request` типа `bool`. Эта модель может использоваться для проверки и сериализации/десериализации ответов API, которые имеют такую структуру.


**6. Функция check_request_limit(), которая проверяет, может ли быть сделан запрос к стороннему API на основе ограничения запроса и периода запрета.**


Построчно:


1.) `db = SessionLocal()`: Эта строка создает новый объект session путем вызова функции `SessionLocal`. Объект session представляет транзакционную область для взаимодействия с базой данных.


2.) `counter = db.query(RequestCounter).first()`: Эта строка запрашивает таблицу `RequestCounter` в базе данных, используя объект `db`, и извлекает первую строку.


3.) `if counter.count >= 5:`: Эта строка проверяет, больше ли значение столбца `count` в объекте `counter` или равно 5. Это условие проверяет, превысило ли количество запросов ограничение.


4.) `if datetime.now() - timedelta(minutes=20) > counter.updated_at:`: Эта строка проверяет, больше ли текущее время 20 минут, чем значение столбца `updated_at` в объекте `counter`. Это условие проверяет, истек ли период запрета.


5.) `counter.count = 0`: Эта строка устанавливает значение столбца `count` в объекте `counter` равным 0. Это сбрасывает количество запросов.


6.) `db.commit()`: Эта строка фиксирует изменения, внесенные в сеанс базы данных.


7.) `return True`: Эта строка возвращает `True`, если период запрета истек и количество запросов было сброшено.


8.) `return False`: Эта строка возвращает `False`, если период запрета не истек и количество запросов не было сброшено.


9.) `return True`: Эта строка возвращает `True`, если количество запросов не превысило лимит.

В целом, эта функция проверяет, может ли быть сделан запрос к стороннему API, проверяя количество запросов и период запрета. Если количество запросов превысило лимит и период запрета истек, количество запросов сбрасывается и возвращается значение "True". Если срок запрета не истек, возвращается значение "False". Если количество запросов не превысило лимит, возвращается значение "True".


**7. Конечная точка API, определенная с помощью декоратора "@app.get". Эта конечная точка доступна по URL-пути "/check_request_limit".**


Построчно:


1.) `@app.get("/check_request_limit")`: Эта строка принимает функцию `check_request_limit_endpoint()`  в качестве аргумента с помощью декоратора `@app.get`. Этот декоратор указывает, что функция должна вызываться при отправке HTTP-запроса GET по URL-пути `/check_request_limit`.


2.) `def check_request_limit_endpoint()`: Эта строка определяет функцию `check_request_limit_endpoint()`, которая служит обработчиком для конечной точки API.


3.) `can_make_request = check_request_limit()`: Эта строка вызывает функцию `check_request_limit()`, чтобы проверить, может ли быть сделан запрос к стороннему API. Результат сохраняется в переменной `can_make_request`.


4.) `return Response(can_make_request=can_make_request)`: Эта строка возвращает объект `Response` со значением `can_make_request` в качестве тела ответа. Объект `Response` создается с использованием класса модели Pydantic `Response`, определенного ранее.

В целом, этот код устанавливает конечную точку API по URL-пути `/check_request_limit`. Когда к этой конечной точке отправляется запрос GET, она вызывает функцию `check_request_limit()`, чтобы определить, может ли быть сделан запрос к стороннему API. Затем результат возвращается в виде ответа JSON с использованием модели `Response`.



---


**1. Импортируем все нужное, для написание pytest.**


**2. Настраиваем базу данных SQLite для тестирования.**


Построчно:


1.) `SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"`: В этой строке задается URL-адрес базы данных SQLite. В этом случае используется база данных в памяти с URL-адресом `sqlite:///./test.db`. Часть `./test.db` указывает имя файла базы данных как `test.db` в текущем каталоге.


2.) `engine = create_engine(SQLALCHEMY_DATABASE_URL)`: Эта строка создает объект engine, используя функцию `create_engine` из SQLAlchemy. Ядро отвечает за подключение к базе данных и выполнение инструкций SQL. В качестве параметра для указания URL-адреса базы данных передается `SQLALCHEMY_DATABASE_URL`.


3.) `TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)`: Эта строка создает session factory для тестирования, используя функцию `sessionmaker` из SQLAlchemy. Параметры `autocommit=False` и `autoflush=False` настраивают сеанс таким образом, чтобы он автоматически не фиксировал изменения и не сбрасывал ожидающие изменения в базу данных. Параметру `bind` присваивается значение объекта `engine`, созданного на предыдущем шаге, чтобы связать сеанс с database engine.

В целом, этот код настраивает базу данных SQLite в памяти для тестирования путем создания объекта engine и session factory. URL базы данных указан как `sqlite:///./test.db`, и session factory настроена для работы с этой базой данных.


**3. Создаем таблицы базы данных для тестирования на основе моделей SQLAlchemy.**


Построчно:


`Base.metadata.create_all(bind=engine)`: В этой строке используется метод `create_all` атрибута `metadata` класса `Base` для создания таблиц базы данных. Параметру `bind` присваивается значение объекта `engine`, который был создан ранее. Этот метод сканирует все модели (классы, которые наследуются от `Base`) и создает соответствующие таблицы в базе данных, если они еще не существуют.

В целом, эта строка кода создает необходимые таблицы в базе данных SQLite в памяти для тестирования на основе определенных моделей SQLAlchemy.


**4. Переопределяем исходную зависимость "Session Local" с помощью "TestingSessionLocal” для приложения FastAPI.**


Построчно:


`app.dependency_overrides[Session Local] = Testing Session Local":` Эта строка определяет исходную зависимость Session Local, используемую приложением FastAPI, с помощью `"TestingSessionLocal".` Атрибут dependency_overrides в “app” представляет собой объект, подобный словарю, который позволяет переопределять зависимости, используемые приложением.

Переопределяя зависимость "Session Local", любая часть приложения, зависящая от "SessionLocal", теперь будет использовать вместо этого "TestingSessionLocal".


**5. test_check_request_limit(), которая проверяет поведение конечной точки API /check_request_limit.**


Построчно:


1.) `client = TestClient(app)`: Эта строка создает объект `TestClient`, используя класс `TestClient`, предоставляемый FastAPI. Объект `TestClient` позволяет нам отправлять HTTP-запросы к приложению FastAPI для тестирования.


2.) `response = client.get("/check_request_limit")`: Эта строка отправляет запрос GET на конечную точку `/check_request_limit`, используя объект `client`. Ответ от конечной точки хранится в переменной `response`.


3.) `assert response.status_code == 200`: В этой строке утверждается, что код состояния ответа равен 200, что указывает на успешный запрос.


4.) `assert response.json() == {"can_make_request": True}`: В этой строке утверждается, что тело ответа в формате JSON является `{"can_make_request": True}`. Это проверяет, соответствует ли ответ API ожидаемому результату.


5.) `db = TestingSessionLocal()`: Эта строка создает новый объект session для тестирования с использованием fabric session `TestingSessionLocal`.


6.) `counter = db.query(RequestCounter).first()`: Эта строка запрашивает таблицу `RequestCounter` в тестируемой базе данных для извлечения первой строки.


7.) `counter.count = 5`: Эта строка устанавливает значение столбца `count` в объекте `counter` равным 5, имитируя, что количество запросов достигает предела.


8.) `db.commit()`: Эта строка фиксирует изменения, внесенные в сеанс тестирования базы данных.


9.) `response = client.get("/check_request_limit")`: Эта строка отправляет другой запрос GET на конечную точку `/check_request_limit` для проверки поведения, когда количество запросов достигает предела.


10.) `assert response.status_code == 200`: В этой строке утверждается, что код состояния ответа равен 200.


11.) `assert response.json() == {"can_make_request": False}`: Эта строка утверждает, что тело ответа в формате JSON является `{"can_make_request": False}`, указывая, что запрос не может быть выполнен из-за достижения предела.


12.) `counter.updated_at = datetime.now() - timedelta(минуты=21)`: Эта строка устанавливает значение столбца `updated_at` в объекте `counter` на время 21 минуту назад, имитируя истечение периода запрета.


13.) `db.commit()`: Эта строка фиксирует изменения, внесенные в сеанс тестирования базы данных.


14.) `response = client.get("/check_request_limit")`: Эта строка отправляет другой запрос GET на конечную точку `/check_request_limit` для проверки поведения по истечении периода запрета.


15.) `assert response.status_code == 200`: В этой строке утверждается, что код состояния ответа равен 200.


16.) `assert response.json() == {"can_make_request": True}`: Эта строка утверждает, что текст ответа в формате JSON равен `{"can_make_request": True}`, указывая, что запрос может быть сделан после истечения периода запрета.


17.) `counter.updated_at = datetime.now() - timedelta(minutes=19)`: Эта строка устанавливает значение столбца `updated_at` в объекте `counter` на время 19 минут назад, имитируя еще не истекший период запрета.


18.) `db.commit()`: Эта строка фиксирует изменения, внесенные в сеанс тестирования базы данных.


19.) `response = client.get("/check_request_limit")`: Эта строка отправляет запрос GET на конечную точку `/check_request_limit` для проверки поведения, когда период запрета еще не истек.


20.) `assert response.status_code == 200`: В этой строке утверждается, что код состояния ответа равен 200.


21.) `assert response.json() == {"can_make_request": False}`: Эта строка утверждает, что текст ответа в формате JSON равен `{"can_make_request": False}`, указывая, что запрос не может быть выполнен, поскольку период запрета не истек.

В целом, эта тестовая функция проверяет поведение конечной точки API `/check_request_limit` в различных сценариях, например, когда количество запросов ниже предела, когда количество запросов достигает предела и когда истек период запрета. Он использует объект `TestClient` для выполнения HTTP-запросов и утверждает ожидаемые ответы.


---
